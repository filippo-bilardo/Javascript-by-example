<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>05.02 - Tecniche di Ottimizzazione</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #764ba2;
        }

        .info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .warning {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .success {
            background: #d4edda;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #28a745;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
        }

        .input-group {
            margin: 20px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input[type="text"], textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .result {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #764ba2;
        }

        code {
            background: #e3f2fd;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #764ba2;
            font-weight: bold;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #667eea;
            color: white;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }

        .comparison-card.bad {
            border-color: #f44336;
            background: #ffebee;
        }

        .comparison-card.good {
            border-color: #28a745;
            background: #d4edda;
        }

        .optimization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .opt-card {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
        }

        .opt-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ 05.02 - Tecniche di Ottimizzazione</h1>

        <!-- Sezione 1: Gruppi Non Catturanti -->
        <div class="section">
            <h2>üì¶ Gruppi Non Catturanti (?:...)</h2>
            
            <div class="info">
                <h3>Perch√© usare gruppi non catturanti?</h3>
                <p><strong>Gruppi catturanti:</strong> <code>(...)</code> ‚Üí Salvano il match in memoria</p>
                <p><strong>Gruppi non catturanti:</strong> <code>(?:...)</code> ‚Üí NON salvano, solo raggruppano</p>
                <p>üí° Usa <code>(?:...)</code> quando non ti servono i gruppi catturati!</p>
            </div>

            <div class="code-block">
<span style="color:#6272a4">// Con gruppi catturanti - SPRECA MEMORIA</span>
<span style="color:#ff79c6">const</span> withCapture = <span style="color:#ff6b6b">/(\d{4})-(\d{2})-(\d{2})/</span>;
<span style="color:#f1fa8c">"2023-10-15"</span>.<span style="color:#50fa7b">match</span>(withCapture);
<span style="color:#6272a4">// ["2023-10-15", "2023", "10", "15"] ‚Üê 3 gruppi salvati</span>

<span style="color:#6272a4">// Con gruppi NON catturanti - PI√ô VELOCE</span>
<span style="color:#ff79c6">const</span> nonCapturing = <span style="color:#ff6b6b">/(?:\d{4})-(?:\d{2})-(?:\d{2})/</span>;
<span style="color:#f1fa8c">"2023-10-15"</span>.<span style="color:#50fa7b">match</span>(nonCapturing);
<span style="color:#6272a4">// ["2023-10-15"] ‚Üê solo match completo</span>

<span style="color:#6272a4">// Usa catturanti SOLO se ti servono!</span>
<span style="color:#ff79c6">const</span> mixed = <span style="color:#ff6b6b">/(\d{4})-(?:\d{2})-(?:\d{2})/</span>;
<span style="color:#f1fa8c">"2023-10-15"</span>.<span style="color:#50fa7b">match</span>(mixed);
<span style="color:#6272a4">// ["2023-10-15", "2023"] ‚Üê solo anno catturato</span>
            </div>

            <div class="comparison">
                <div class="comparison-card bad">
                    <h4>‚ùå Gruppi Catturanti Inutili</h4>
                    <pre>// Valida URL
/http(s)?:\/\/(www\.)?(\w+)\.(\w+)/

// Valida password
/((?=.*[A-Z])((?=.*[a-z])).{8,})/

// Alternanza
/(apple|banana|orange)/</pre>
                </div>
                <div class="comparison-card good">
                    <h4>‚úÖ Gruppi Non Catturanti</h4>
                    <pre>// Valida URL
/https?:\/\/(?:www\.)?(?:\w+)\.(?:\w+)/

// Valida password  
/(?:(?=.*[A-Z])(?:(?=.*[a-z])).{8,})/

// Alternanza
/(?:apple|banana|orange)/</pre>
                </div>
            </div>

            <button onclick="benchmarkCapturingGroups()">Benchmark Gruppi</button>
            <button onclick="demonstrateMemoryUsage()">Dimostra Uso Memoria</button>

            <div id="result1" class="result" style="display:none;"></div>
        </div>

        <!-- Sezione 2: Ottimizzazione Alternanze -->
        <div class="section">
            <h2>üîÄ Ottimizzazione Alternanze</h2>
            
            <div class="info">
                <h3>Problema delle alternanze:</h3>
                <p>Il motore regex prova OGNI alternativa in ordine ‚Üí pu√≤ essere lento</p>
            </div>

            <div class="code-block">
<span style="color:#6272a4">// LENTO: Prova ogni alternativa</span>
<span style="color:#ff79c6">const</span> slow = <span style="color:#ff6b6b">/apple|banana|apricot|blueberry|blackberry/</span>;

<span style="color:#6272a4">// VELOCE: Raggruppa per primo carattere</span>
<span style="color:#ff79c6">const</span> fast = <span style="color:#ff6b6b">/a(?:pple|pricot)|b(?:anana|lueberry|lackberry)/</span>;

<span style="color:#6272a4">// ANCORA PI√ô VELOCE: Classe caratteri + suffisso</span>
<span style="color:#ff79c6">const</span> faster = <span style="color:#ff6b6b">/[ab](?:pple|pricot|anana|lueberry|lackberry)/</span>;

<span style="color:#6272a4">// ESEMPIO: URL protocols</span>
<span style="color:#6272a4">// Lento</span>
<span style="color:#ff79c6">const</span> protocolsSlow = <span style="color:#ff6b6b">/http|https|ftp|ftps|sftp/</span>;

<span style="color:#6272a4">// Veloce</span>
<span style="color:#ff79c6">const</span> protocolsFast = <span style="color:#ff6b6b">/(?:https?|ftps?|sftp)/</span>;
            </div>

            <div class="warning">
                <h4>‚ö†Ô∏è Ordine delle alternanze:</h4>
                <p>Metti le alternative PI√ô PROBABILI per prime!</p>
                <p>Metti le alternative PI√ô LUNGHE per prime (evita match parziali)!</p>
            </div>

            <div class="code-block">
<span style="color:#6272a4">// SBAGLIATO: 'in' matcha prima di 'international'</span>
<span style="color:#ff79c6">const</span> wrong = <span style="color:#ff6b6b">/\b(in|international)\b/</span>;
<span style="color:#f1fa8c">"international"</span>.<span style="color:#50fa7b">match</span>(wrong);  <span style="color:#6272a4">// ["in"] ‚Üê ERRORE!</span>

<span style="color:#6272a4">// CORRETTO: Lunghe per prime</span>
<span style="color:#ff79c6">const</span> correct = <span style="color:#ff6b6b">/\b(international|in)\b/</span>;
<span style="color:#f1fa8c">"international"</span>.<span style="color:#50fa7b">match</span>(correct);  <span style="color:#6272a4">// ["international"] ‚úÖ</span>
            </div>

            <div class="input-group">
                <label>Alternanze da testare (separate da |):</label>
                <input type="text" id="alternations" value="apple|banana|apricot|blueberry|blackberry" placeholder="alt1|alt2|alt3">
            </div>

            <button onclick="optimizeAlternations()">Ottimizza Alternanze</button>
            <button onclick="benchmarkAlternations()">Benchmark Alternanze</button>

            <div id="result2" class="result" style="display:none;"></div>
        </div>

        <!-- Sezione 3: Uso Efficiente di Lookahead/Lookbehind -->
        <div class="section">
            <h2>üëÄ Uso Efficiente di Lookahead/Lookbehind</h2>
            
            <div class="warning">
                <h3>‚ö†Ô∏è Assertions possono essere lente!</h3>
                <p>Ogni assertion richiede un controllo separato</p>
                <p>Troppe assertions = performance degradata</p>
            </div>

            <div class="code-block">
<span style="color:#6272a4">// LENTO: Troppe assertions</span>
<span style="color:#ff79c6">const</span> slowPwd = <span style="color:#ff6b6b">/^
    (?=.*[a-z])
    (?=.*[A-Z])
    (?=.*\d)
    (?=.*[@$!%*?&])
    (?!.*(.)\1{2})
    (?!.*(password|123|abc))
    .{8,}
$/x</span>;

<span style="color:#6272a4">// VELOCE: Logica separata</span>
<span style="color:#ff79c6">function</span> <span style="color:#50fa7b">validatePassword</span>(pwd) {
    <span style="color:#ff79c6">if</span> (pwd.<span style="color:#50fa7b">length</span> &lt; <span style="color:#bd93f9">8</span>) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">if</span> (!<span style="color:#ff6b6b">/[a-z]/</span>.<span style="color:#50fa7b">test</span>(pwd)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">if</span> (!<span style="color:#ff6b6b">/[A-Z]/</span>.<span style="color:#50fa7b">test</span>(pwd)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">if</span> (!<span style="color:#ff6b6b">/\d/</span>.<span style="color:#50fa7b">test</span>(pwd)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">if</span> (!<span style="color:#ff6b6b">/[@$!%*?&]/</span>.<span style="color:#50fa7b">test</span>(pwd)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">if</span> (<span style="color:#ff6b6b">/(.)\1{2}/</span>.<span style="color:#50fa7b">test</span>(pwd)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">if</span> (<span style="color:#ff6b6b">/(password|123|abc)/i</span>.<span style="color:#50fa7b">test</span>(pwd)) <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>;
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>;
}
<span style="color:#6272a4">// Vantaggi:</span>
<span style="color:#6272a4">// - Early return su primo fallimento (pi√π veloce)</span>
<span style="color:#6272a4">// - Pi√π leggibile e manutenibile</span>
<span style="color:#6272a4">// - Messaggi di errore specifici possibili</span>
            </div>

            <div class="success">
                <h4>‚úÖ Quando usare assertions vs logica separata:</h4>
                <table style="background: white; margin: 10px 0;">
                    <tr><th>Usa Assertions</th><th>Usa Logica Separata</th></tr>
                    <tr><td>1-2 assertions semplici</td><td>3+ assertions</td></tr>
                    <tr><td>Validazione inline veloce</td><td>Validazione complessa</td></tr>
                    <tr><td>Pattern gi√† esistente</td><td>Servono messaggi di errore</td></tr>
                    <tr><td>Non serve debugging</td><td>Serve debugging/testing</td></tr>
                </table>
            </div>

            <button onclick="benchmarkAssertions()">Benchmark Assertions</button>
            <button onclick="compareApproaches()">Confronta Approcci</button>

            <div id="result3" class="result" style="display:none;"></div>
        </div>

        <!-- Sezione 4: Compilazione e Riuso Pattern -->
        <div class="section">
            <h2>‚ôªÔ∏è Compilazione e Riuso Pattern</h2>
            
            <div class="info">
                <h3>Principio chiave:</h3>
                <p><strong>Compila UNA VOLTA</strong> - Riusa MOLTE VOLTE</p>
                <p>Creare una regex ha un costo ‚Üí riutilizzala!</p>
            </div>

            <div class="comparison">
                <div class="comparison-card bad">
                    <h4>‚ùå Compila Ogni Volta</h4>
                    <pre>// IN UN LOOP - LENTO!
data.forEach(item => {
    if (/^\d{4}-\d{2}-\d{2}$/.test(item)) {
        // ...
    }
});

// Crea regex ogni chiamata
function validate(text) {
    return /pattern/.test(text);
}</pre>
                </div>
                <div class="comparison-card good">
                    <h4>‚úÖ Compila Una Volta</h4>
                    <pre>// FUORI DAL LOOP - VELOCE!
const datePattern = /^\d{4}-\d{2}-\d{2}$/;
data.forEach(item => {
    if (datePattern.test(item)) {
        // ...
    }
});

// Riusa regex esistente
const PATTERN = /pattern/;
function validate(text) {
    return PATTERN.test(text);
}</pre>
                </div>
            </div>

            <div class="code-block">
<span style="color:#6272a4">// ESEMPIO PRATICO: Validazione email in array</span>

<span style="color:#6272a4">// LENTO: Compila 1000 volte!</span>
<span style="color:#ff79c6">function</span> <span style="color:#50fa7b">validateEmailsSlow</span>(emails) {
    <span style="color:#ff79c6">return</span> emails.<span style="color:#50fa7b">filter</span>(<span style="color:#ff79c6">e</span> <span style="color:#ff79c6">=&gt;</span> 
        <span style="color:#ff6b6b">/^[\w.-]+@[\w.-]+\.\w+$/</span>.<span style="color:#50fa7b">test</span>(e)
    );
}

<span style="color:#6272a4">// VELOCE: Compila 1 volta!</span>
<span style="color:#ff79c6">const</span> <span style="color:#bd93f9">EMAIL_PATTERN</span> = <span style="color:#ff6b6b">/^[\w.-]+@[\w.-]+\.\w+$/</span>;
<span style="color:#ff79c6">function</span> <span style="color:#50fa7b">validateEmailsFast</span>(emails) {
    <span style="color:#ff79c6">return</span> emails.<span style="color:#50fa7b">filter</span>(<span style="color:#ff79c6">e</span> <span style="color:#ff79c6">=&gt;</span> <span style="color:#bd93f9">EMAIL_PATTERN</span>.<span style="color:#50fa7b">test</span>(e));
}

<span style="color:#6272a4">// Con 10,000 email, la differenza √® ENORME!</span>
            </div>

            <div class="warning">
                <h4>‚ö†Ô∏è Attenzione con flag /g (global):</h4>
                <p>Il flag <code>/g</code> mantiene stato (lastIndex)</p>
                <p>Resetta con <code>regex.lastIndex = 0</code> o usa .test() senza /g</p>
            </div>

            <button onclick="benchmarkReuse()">Benchmark Riuso Pattern</button>
            <button onclick="demonstrateGlobalFlag()">Dimostra Problema /g</button>

            <div id="result4" class="result" style="display:none;"></div>
        </div>

        <!-- Sezione 5: Specificit√† vs Generalit√† -->
        <div class="section">
            <h2>üéØ Specificit√† vs Generalit√†</h2>
            
            <div class="info">
                <h3>Regola d'oro:</h3>
                <p><strong>Sii il pi√π SPECIFICO possibile!</strong></p>
                <p>Pattern generici = pi√π backtracking = pi√π lenti</p>
            </div>

            <div class="optimization-grid">
                <div class="opt-card">
                    <h4>Numeri</h4>
                    <pre>‚ùå /\d+/
‚úÖ /\d{1,3}/
‚úÖ /[0-9]{4}/</pre>
                    <p>Specifica lunghezza esatta/range</p>
                </div>
                <div class="opt-card">
                    <h4>Testo</h4>
                    <pre>‚ùå /.*/
‚úÖ /\w{5,20}/
‚úÖ /[a-zA-Z]+/</pre>
                    <p>Specifica tipo e lunghezza</p>
                </div>
                <div class="opt-card">
                    <h4>Whitespace</h4>
                    <pre>‚ùå /\s+/
‚úÖ / +/
‚úÖ /[ \t]+/</pre>
                    <p>Solo spazi necessari</p>
                </div>
                <div class="opt-card">
                    <h4>Alternative</h4>
                    <pre>‚ùå /.+/
‚úÖ /(?:yes|no)/
‚úÖ /[yn]es/</pre>
                    <p>Valori espliciti</p>
                </div>
            </div>

            <div class="code-block">
<span style="color:#6272a4">// ESEMPIO: Parsing log entry</span>

<span style="color:#6272a4">// GENERICO (lento, permissivo)</span>
<span style="color:#ff79c6">const</span> generic = <span style="color:#ff6b6b">/(\S+)\s+(\S+)\s+(.+)/</span>;

<span style="color:#6272a4">// SPECIFICO (veloce, preciso)</span>
<span style="color:#ff79c6">const</span> specific = <span style="color:#ff6b6b">/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+(\w+)\s+(GET|POST|PUT|DELETE)\s+(\/\S+)/</span>;

<span style="color:#6272a4">// Il pattern specifico:</span>
<span style="color:#6272a4">// - √à pi√π veloce (meno backtracking)</span>
<span style="color:#6272a4">// - Valida meglio (cattura errori)</span>
<span style="color:#6272a4">// - Documenta il formato atteso</span>
            </div>

            <button onclick="compareSpecificity()">Confronta Specificit√†</button>
            <button onclick="demonstrateValidation()">Validazione vs Performance</button>

            <div id="result5" class="result" style="display:none;"></div>
        </div>

        <!-- Sezione 6: Tecniche Avanzate di Ottimizzazione -->
        <div class="section">
            <h2>‚ö° Tecniche Avanzate</h2>
            
            <div class="optimization-grid">
                <div class="opt-card">
                    <h4>1. Possessive Quantifiers</h4>
                    <pre>// Non supportato in JS!
// In altri linguaggi:
/a++b/  // NO backtrack</pre>
                    <p>JS: usa atomic groups alternative</p>
                </div>
                <div class="opt-card">
                    <h4>2. Atomic Groups</h4>
                    <pre>// Non nativo in JS
// Workaround con lookahead:
/(?=(a+))b\1/</pre>
                    <p>Previene backtracking</p>
                </div>
                <div class="opt-card">
                    <h4>3. Fail Fast</h4>
                    <pre>// Controlla prima condizioni
if (!text.includes('@')) {
    return false; // ‚úÖ Veloce!
}
return /@/.test(text);</pre>
                    <p>Pre-check semplici</p>
                </div>
                <div class="opt-card">
                    <h4>4. String Methods</h4>
                    <pre>// Quando possibile, usa:
text.includes('x')    // ‚úÖ
text.startsWith('x')  // ‚úÖ
text.endsWith('x')    // ‚úÖ
// Invece di regex!</pre>
                    <p>Metodi nativi sono pi√π veloci</p>
                </div>
            </div>

            <div class="success">
                <h3>‚úÖ Checklist Ottimizzazione:</h3>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>‚úì Usa gruppi non catturanti <code>(?:...)</code> se non serve cattura</li>
                    <li>‚úì Ottimizza alternanze (raggruppa per prefisso comune)</li>
                    <li>‚úì Limita assertions a max 2-3 per pattern</li>
                    <li>‚úì Compila pattern UNA volta, riusa MOLTE volte</li>
                    <li>‚úì Sii SPECIFICO: specifica lunghezza e tipo caratteri</li>
                    <li>‚úì Usa ancoraggi <code>^</code>, <code>$</code>, <code>\b</code> quando possibile</li>
                    <li>‚úì Preferisci classi negate <code>[^x]</code> a <code>.*?</code></li>
                    <li>‚úì Pre-check con metodi stringa prima di regex</li>
                    <li>‚úì Evita quantificatori annidati <code>(a+)+</code></li>
                    <li>‚úì Testa performance con dati realistici</li>
                </ul>
            </div>

            <button onclick="runOptimizationChecklist()">Analizza Pattern</button>
            <button onclick="suggestOptimizations()">Suggerisci Ottimizzazioni</button>

            <div id="result6" class="result" style="display:none;"></div>
        </div>
    </div>

    <script>
        // Sezione 1: Gruppi Non Catturanti
        function benchmarkCapturingGroups() {
            const text = '2023-10-15';
            const withCapture = /(\d{4})-(\d{2})-(\d{2})/;
            const nonCapturing = /(?:\d{4})-(?:\d{2})-(?:\d{2})/;
            const iterations = 100000;
            
            let start = performance.now();
            for (let i = 0; i < iterations; i++) {
                withCapture.test(text);
            }
            let captureTime = performance.now() - start;
            
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                nonCapturing.test(text);
            }
            let nonCaptureTime = performance.now() - start;
            
            const speedup = ((captureTime - nonCaptureTime) / captureTime * 100).toFixed(1);
            
            document.getElementById('result1').style.display = 'block';
            document.getElementById('result1').innerHTML = `
                <h3>Benchmark Gruppi (${iterations.toLocaleString()} iterazioni):</h3>
                <table>
                    <tr><th>Pattern</th><th>Tempo (ms)</th><th>Differenza</th></tr>
                    <tr>
                        <td><code>/(\d{4})-(\d{2})-(\d{2})/</code></td>
                        <td>${captureTime.toFixed(2)}</td>
                        <td>Baseline</td>
                    </tr>
                    <tr>
                        <td><code>/(?:\d{4})-(?:\d{2})-(?:\d{2})/</code></td>
                        <td>${nonCaptureTime.toFixed(2)}</td>
                        <td class="highlight">${speedup}% pi√π veloce</td>
                    </tr>
                </table>
                <div class="success">
                    <p>‚úÖ I gruppi non catturanti sono ${speedup}% pi√π veloci!</p>
                    <p>Con pattern complessi, la differenza aumenta.</p>
                </div>
            `;
        }

        function demonstrateMemoryUsage() {
            const text = '2023-10-15 foo bar baz';
            const withCapture = /(\d{4})-(\d{2})-(\d{2}) (\w+) (\w+) (\w+)/;
            const nonCapturing = /(?:\d{4})-(?:\d{2})-(?:\d{2}) (?:\w+) (?:\w+) (?:\w+)/;
            
            const captureResult = text.match(withCapture);
            const nonCaptureResult = text.match(nonCapturing);
            
            document.getElementById('result1').style.display = 'block';
            document.getElementById('result1').innerHTML = `
                <h3>Uso Memoria:</h3>
                <p><strong>Testo:</strong> "${text}"</p>
                <div class="comparison">
                    <div class="comparison-card bad">
                        <h4>Con Cattura</h4>
                        <p><code>${withCapture}</code></p>
                        <p><strong>Risultato:</strong></p>
                        <pre>${JSON.stringify(captureResult, null, 2)}</pre>
                        <p><strong>Elementi:</strong> ${captureResult.length}</p>
                        <p>Salva ${captureResult.length - 1} gruppi in memoria</p>
                    </div>
                    <div class="comparison-card good">
                        <h4>Senza Cattura</h4>
                        <p><code>${nonCapturing}</code></p>
                        <p><strong>Risultato:</strong></p>
                        <pre>${JSON.stringify(nonCaptureResult, null, 2)}</pre>
                        <p><strong>Elementi:</strong> ${nonCaptureResult.length}</p>
                        <p>Solo match completo, nessun gruppo</p>
                    </div>
                </div>
                <div class="info">
                    <p>üí° Usa <code>(?:...)</code> quando non ti servono i gruppi catturati!</p>
                </div>
            `;
        }

        // Sezione 2: Alternanze
        function optimizeAlternations() {
            const input = document.getElementById('alternations').value;
            const alts = input.split('|').map(a => a.trim());
            
            // Raggruppa per primo carattere
            const grouped = {};
            alts.forEach(alt => {
                const first = alt[0];
                if (!grouped[first]) grouped[first] = [];
                grouped[first].push(alt.substring(1));
            });
            
            // Genera pattern ottimizzato
            const optimized = Object.entries(grouped).map(([first, suffixes]) => {
                if (suffixes.length === 1 && suffixes[0] === '') {
                    return first;
                }
                return first + '(?:' + suffixes.join('|') + ')';
            }).join('|');
            
            document.getElementById('result2').style.display = 'block';
            document.getElementById('result2').innerHTML = `
                <h3>Ottimizzazione Alternanze:</h3>
                <div class="comparison">
                    <div class="comparison-card bad">
                        <h4>Originale</h4>
                        <pre>/${input}/</pre>
                        <p>Prova ogni alternativa in ordine</p>
                    </div>
                    <div class="comparison-card good">
                        <h4>Ottimizzato</h4>
                        <pre>/${optimized}/</pre>
                        <p>Raggruppa per primo carattere</p>
                    </div>
                </div>
                <div class="info">
                    <h4>Analisi:</h4>
                    <p>‚Ä¢ Alternanze originali: ${alts.length}</p>
                    <p>‚Ä¢ Gruppi ottimizzati: ${Object.keys(grouped).length}</p>
                    <p>‚Ä¢ Risparmio: ${((1 - Object.keys(grouped).length / alts.length) * 100).toFixed(1)}%</p>
                </div>
            `;
        }

        function benchmarkAlternations() {
            const text = 'blueberry';
            const slow = /apple|banana|apricot|blueberry|blackberry/;
            const fast = /a(?:pple|pricot)|b(?:anana|lueberry|lackberry)/;
            const iterations = 100000;
            
            let start = performance.now();
            for (let i = 0; i < iterations; i++) {
                slow.test(text);
            }
            let slowTime = performance.now() - start;
            
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                fast.test(text);
            }
            let fastTime = performance.now() - start;
            
            document.getElementById('result2').style.display = 'block';
            document.getElementById('result2').innerHTML = `
                <h3>Benchmark Alternanze (${iterations.toLocaleString()} iterazioni):</h3>
                <p><strong>Testo cercato:</strong> "${text}"</p>
                <table>
                    <tr><th>Pattern</th><th>Tempo (ms)</th><th>Speedup</th></tr>
                    <tr>
                        <td>Non ottimizzato</td>
                        <td>${slowTime.toFixed(2)}</td>
                        <td>Baseline</td>
                    </tr>
                    <tr>
                        <td>Ottimizzato</td>
                        <td>${fastTime.toFixed(2)}</td>
                        <td class="highlight">${(slowTime / fastTime).toFixed(2)}x</td>
                    </tr>
                </table>
                <div class="success">
                    <p>‚úÖ Pattern ottimizzato √® ${(slowTime / fastTime).toFixed(2)}x pi√π veloce!</p>
                </div>
            `;
        }

        // Sezione 3: Assertions
        function benchmarkAssertions() {
            const pwd = 'MyPass123!';
            const withAssertions = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&]).{8,}$/;
            const iterations = 10000;
            
            function validateSeparate(pwd) {
                if (pwd.length < 8) return false;
                if (!/[a-z]/.test(pwd)) return false;
                if (!/[A-Z]/.test(pwd)) return false;
                if (!/\d/.test(pwd)) return false;
                if (!/[@$!%*?&]/.test(pwd)) return false;
                return true;
            }
            
            let start = performance.now();
            for (let i = 0; i < iterations; i++) {
                withAssertions.test(pwd);
            }
            let assertTime = performance.now() - start;
            
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                validateSeparate(pwd);
            }
            let separateTime = performance.now() - start;
            
            document.getElementById('result3').style.display = 'block';
            document.getElementById('result3').innerHTML = `
                <h3>Benchmark Validazione Password (${iterations.toLocaleString()} iterazioni):</h3>
                <table>
                    <tr><th>Approccio</th><th>Tempo (ms)</th><th>Differenza</th></tr>
                    <tr>
                        <td>Assertions multiple</td>
                        <td>${assertTime.toFixed(2)}</td>
                        <td>Baseline</td>
                    </tr>
                    <tr>
                        <td>Test separati</td>
                        <td>${separateTime.toFixed(2)}</td>
                        <td class="highlight">${((assertTime - separateTime) / assertTime * 100).toFixed(1)}% pi√π veloce</td>
                    </tr>
                </table>
                <div class="success">
                    <p>‚úÖ Test separati permettono early return ‚Üí pi√π veloci!</p>
                    <p>Pi√π assertions = maggiore vantaggio test separati</p>
                </div>
            `;
        }

        function compareApproaches() {
            document.getElementById('result3').style.display = 'block';
            document.getElementById('result3').innerHTML = `
                <h3>Confronto Approcci Validazione:</h3>
                <table>
                    <tr><th>Caratteristica</th><th>Assertions Multiple</th><th>Test Separati</th></tr>
                    <tr><td>Compattezza</td><td>‚úÖ 1 riga</td><td>‚ùå Pi√π righe</td></tr>
                    <tr><td>Leggibilit√†</td><td>‚ùå Complesso</td><td>‚úÖ Chiaro</td></tr>
                    <tr><td>Performance</td><td>‚ùå Pi√π lento</td><td>‚úÖ Pi√π veloce</td></tr>
                    <tr><td>Debugging</td><td>‚ùå Difficile</td><td>‚úÖ Facile</td></tr>
                    <tr><td>Messaggi errore</td><td>‚ùå Impossibile</td><td>‚úÖ Possibile</td></tr>
                    <tr><td>Testing</td><td>‚ùå Un blocco</td><td>‚úÖ Granulare</td></tr>
                    <tr><td>Manutenibilit√†</td><td>‚ùå Bassa</td><td>‚úÖ Alta</td></tr>
                </table>
                <div class="info">
                    <h4>üí° Raccomandazione:</h4>
                    <p><strong>1-2 assertions:</strong> OK usare regex</p>
                    <p><strong>3+ assertions:</strong> Preferisci test separati</p>
                    <p><strong>Validazione complessa:</strong> SEMPRE test separati</p>
                </div>
            `;
        }

        // Sezione 4: Riuso Pattern
        function benchmarkReuse() {
            const emails = Array(1000).fill('user@example.com');
            const iterations = 100;
            
            // Compila ogni volta
            let start = performance.now();
            for (let i = 0; i < iterations; i++) {
                emails.filter(e => /^[\w.-]+@[\w.-]+\.\w+$/.test(e));
            }
            let compileEveryTime = performance.now() - start;
            
            // Compila una volta
            const EMAIL = /^[\w.-]+@[\w.-]+\.\w+$/;
            start = performance.now();
            for (let i = 0; i < iterations; i++) {
                emails.filter(e => EMAIL.test(e));
            }
            let compileOnce = performance.now() - start;
            
            document.getElementById('result4').style.display = 'block';
            document.getElementById('result4').innerHTML = `
                <h3>Benchmark Riuso Pattern:</h3>
                <p><strong>Array:</strong> ${emails.length} email</p>
                <p><strong>Iterazioni:</strong> ${iterations}</p>
                <table>
                    <tr><th>Approccio</th><th>Tempo (ms)</th><th>Speedup</th></tr>
                    <tr>
                        <td>Compila ogni volta</td>
                        <td>${compileEveryTime.toFixed(2)}</td>
                        <td>Baseline</td>
                    </tr>
                    <tr>
                        <td>Compila una volta</td>
                        <td>${compileOnce.toFixed(2)}</td>
                        <td class="highlight">${(compileEveryTime / compileOnce).toFixed(2)}x pi√π veloce</td>
                    </tr>
                </table>
                <div class="success">
                    <p>‚úÖ Riutilizzo pattern: ${(compileEveryTime / compileOnce).toFixed(2)}x pi√π veloce!</p>
                    <p>Con ${emails.length * iterations} test, risparmio = ${(compileEveryTime - compileOnce).toFixed(2)}ms</p>
                </div>
            `;
        }

        function demonstrateGlobalFlag() {
            const text = 'test test test';
            const regex = /test/g;
            
            const results = [];
            results.push(`Prima: test("${text}") = ${regex.test(text)}, lastIndex = ${regex.lastIndex}`);
            results.push(`Seconda: test("${text}") = ${regex.test(text)}, lastIndex = ${regex.lastIndex}`);
            results.push(`Terza: test("${text}") = ${regex.test(text)}, lastIndex = ${regex.lastIndex}`);
            results.push(`Quarta: test("${text}") = ${regex.test(text)}, lastIndex = ${regex.lastIndex}`);
            
            document.getElementById('result4').style.display = 'block';
            document.getElementById('result4').innerHTML = `
                <h3>Problema Flag /g con .test():</h3>
                <p><strong>Pattern:</strong> <code>/test/g</code></p>
                <p><strong>Testo:</strong> "${text}"</p>
                <div class="warning">
                    <h4>‚ö†Ô∏è Comportamento:</h4>
                    ${results.map(r => `<p>${r}</p>`).join('')}
                </div>
                <div class="info">
                    <h4>üí° Soluzione:</h4>
                    <p>1. NON usare /g con .test() se riusi la regex</p>
                    <p>2. Oppure resetta: <code>regex.lastIndex = 0</code></p>
                    <p>3. Oppure usa match() invece di test()</p>
                </div>
            `;
        }

        // Sezione 5: Specificit√†
        function compareSpecificity() {
            const log = '192.168.1.100 GET /api/users';
            const generic = /(\S+)\s+(\S+)\s+(\S+)/;
            const specific = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+(GET|POST|PUT|DELETE)\s+(\/\S+)/;
            
            const genMatch = log.match(generic);
            const specMatch = log.match(specific);
            
            document.getElementById('result5').style.display = 'block';
            document.getElementById('result5').innerHTML = `
                <h3>Specificit√† vs Generalit√†:</h3>
                <p><strong>Log entry:</strong> "${log}"</p>
                <div class="comparison">
                    <div class="comparison-card bad">
                        <h4>Generico</h4>
                        <pre>/(\\S+)\\s+(\\S+)\\s+(\\S+)/</pre>
                        <p><strong>Match:</strong> ${genMatch ? 'SI' : 'NO'}</p>
                        ${genMatch ? `<p>Gruppi: ${JSON.stringify(genMatch.slice(1))}</p>` : ''}
                        <p>‚úó Accetta QUALSIASI cosa</p>
                        <p>‚úó Non valida formato</p>
                    </div>
                    <div class="comparison-card good">
                        <h4>Specifico</h4>
                        <pre>/(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+(GET|POST|PUT|DELETE)\\s+(\\/\\S+)/</pre>
                        <p><strong>Match:</strong> ${specMatch ? 'SI' : 'NO'}</p>
                        ${specMatch ? `<p>Gruppi: ${JSON.stringify(specMatch.slice(1))}</p>` : ''}
                        <p>‚úì Valida formato IP</p>
                        <p>‚úì Solo HTTP methods validi</p>
                        <p>‚úì Path deve iniziare con /</p>
                    </div>
                </div>
            `;
        }

        function demonstrateValidation() {
            const tests = [
                '192.168.1.100 GET /api/users',
                'invalid-ip GET /path',
                '192.168.1.1 INVALID /path',
                '192.168.1.1 GET nopath'
            ];
            
            const generic = /(\S+)\s+(\S+)\s+(\S+)/;
            const specific = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+(GET|POST|PUT|DELETE)\s+(\/\S+)/;
            
            document.getElementById('result5').style.display = 'block';
            document.getElementById('result5').innerHTML = `
                <h3>Validazione: Generico vs Specifico</h3>
                <table>
                    <tr><th>Test Case</th><th>Generico</th><th>Specifico</th></tr>
                    ${tests.map(test => `
                        <tr>
                            <td>${test}</td>
                            <td>${generic.test(test) ? '‚úÖ Match' : '‚ùå No match'}</td>
                            <td>${specific.test(test) ? '‚úÖ Match' : '‚ùå No match'}</td>
                        </tr>
                    `).join('')}
                </table>
                <div class="success">
                    <p>‚úÖ Pattern specifico VALIDA correttamente!</p>
                    <p>Generico accetta input invalidi ‚Üí pericoloso!</p>
                </div>
            `;
        }

        // Sezione 6: Tecniche Avanzate
        function runOptimizationChecklist() {
            const pattern = prompt('Inserisci pattern da analizzare:', '(\\d+)-(\\d+)-(\\d+)');
            if (!pattern) return;
            
            const issues = [];
            const suggestions = [];
            
            // Check capturing groups
            const capturingGroups = (pattern.match(/\([^?]/g) || []).length;
            if (capturingGroups > 0) {
                issues.push(`${capturingGroups} gruppi catturanti trovati`);
                suggestions.push('Usa (?:...) se non serve catturare');
            }
            
            // Check nested quantifiers
            if (/[*+]\)[\*+]/.test(pattern)) {
                issues.push('Quantificatori annidati rilevati!');
                suggestions.push('PERICOLO: Rimuovi annidamento per evitare catastrophic backtracking');
            }
            
            // Check .*
            if (/\.\*/.test(pattern)) {
                issues.push('.* trovato');
                suggestions.push('Considera [^x]* per specificare cosa NON matchare');
            }
            
            // Check alternations
            const alternations = (pattern.match(/\|/g) || []).length;
            if (alternations > 3) {
                issues.push(`${alternations + 1} alternanze trovate`);
                suggestions.push('Ottimizza raggruppando per prefisso comune');
            }
            
            // Check anchors
            if (!/^\^/.test(pattern)) {
                suggestions.push('Aggiungi ^ se sai che il pattern √® all\'inizio');
            }
            if (!/\$$/.test(pattern)) {
                suggestions.push('Aggiungi $ se sai che il pattern √® alla fine');
            }
            
            document.getElementById('result6').style.display = 'block';
            document.getElementById('result6').innerHTML = `
                <h3>Analisi Pattern: <code>/${pattern}/</code></h3>
                ${issues.length > 0 ? `
                    <div class="warning">
                        <h4>‚ö†Ô∏è Issues (${issues.length}):</h4>
                        <ul>${issues.map(i => `<li>${i}</li>`).join('')}</ul>
                    </div>
                ` : '<div class="success"><p>‚úÖ Nessun issue critico trovato</p></div>'}
                ${suggestions.length > 0 ? `
                    <div class="info">
                        <h4>üí° Suggerimenti (${suggestions.length}):</h4>
                        <ul>${suggestions.map(s => `<li>${s}</li>`).join('')}</ul>
                    </div>
                ` : '<div class="success"><p>‚úÖ Pattern gi√† ottimizzato!</p></div>'}
            `;
        }

        function suggestOptimizations() {
            document.getElementById('result6').style.display = 'block';
            document.getElementById('result6').innerHTML = `
                <h3>Guida Rapida Ottimizzazioni:</h3>
                <table>
                    <tr><th>Problema</th><th>Soluzione</th><th>Esempio</th></tr>
                    <tr>
                        <td>Gruppi catturanti inutili</td>
                        <td>Usa (?:...)</td>
                        <td><code>(\\d+)</code> ‚Üí <code>(?:\\d+)</code></td>
                    </tr>
                    <tr>
                        <td>Troppe alternanze</td>
                        <td>Raggruppa per prefisso</td>
                        <td><code>a|b|c</code> ‚Üí <code>[abc]</code></td>
                    </tr>
                    <tr>
                        <td>.* troppo avido</td>
                        <td>Usa classe negata</td>
                        <td><code>.*x</code> ‚Üí <code>[^x]*x</code></td>
                    </tr>
                    <tr>
                        <td>Pattern non ancorato</td>
                        <td>Aggiungi ^ e $</td>
                        <td><code>\\d+</code> ‚Üí <code>^\\d+$</code></td>
                    </tr>
                    <tr>
                        <td>Troppo generico</td>
                        <td>Sii specifico</td>
                        <td><code>\\d+</code> ‚Üí <code>\\d{1,3}</code></td>
                    </tr>
                    <tr>
                        <td>Compila ogni volta</td>
                        <td>Riusa pattern</td>
                        <td>const P = /.../ fuori loop</td>
                    </tr>
                    <tr>
                        <td>Troppe assertions</td>
                        <td>Usa logica separata</td>
                        <td>if + if + if invece di (?=)(?=)</td>
                    </tr>
                    <tr>
                        <td>Quantificatori annidati</td>
                        <td>RIMUOVI subito!</td>
                        <td><code>(a+)+</code> ‚Üí <code>a+</code></td>
                    </tr>
                </table>
            `;
        }
    </script>
</body>
</html>